mysql innodb存储引擎中 有页的概念，一页是16KB,一次性从磁盘中读取16KB的数据到内存中在进行后续处理
存储数据时在内存开辟16KB的数据，在存储时按照主键进行排序（通过指针逻辑排序），满16KB时一次性存入磁盘
一页数据分为多个区域：页目录、用户数据区域
页与页之间也是通过链表链接的
如果主键不是自增的，第一页数据满了后，后面的数据插入第二页，会出现后面数据的主键排序应该位于第一页数据中，这样要调换位置，降低了效率，所以主键用自增的ID就不会出现这种问题

B+树中一个节点就是上述的一页
非叶子节点存储指针(6B)和指向页的序号(int 4B),那一个一页可以存储16*1024/10=1638
假设一条数据是1KB，那么二层B+树可以存储1638*(16KB/1KB)=26208（2万）
三层B+树可以存储1638*1638*(16KB/1KB)=268330608（2600万）

索引就是B+树，创建索引就是生成B+树
innodb存储引擎中，通过主键生成的B+树称为主键索引，一个聚簇索引的B+树可以分为索引页（非叶子节点）和数据页（叶子节点），数据页之间通过链表连接，mysql官网中链表连接是双向的，支持范围查询
如果sql语句查询主键字段，可以走索引，如果不是主键字段要走全表扫描
innodb存储引擎中，非主键索引，叶子节点存储的主键值，再通过回表，通过主键索引查找数据

联合索引 最左侧原理

全表扫描（主键索引的叶子节点，从左向右扫描）

范围查询 索引失效 一个表 a（主键索引）bcd（联合索引）
select * from t where b=1 走bcd联合索引
select * from t where b>1 需要回表很多次，所以走全表扫描，不走bcd联合索引，索引失效
select * from t where b>10 走bcd联合索引，在回表
b>x,mysql会去判断【走bcd联合索引，在回表】、【全表扫描】那种效率高


覆盖索引，一个表 a（主键索引）bcd（联合索引）d 五个字段
select b from t where b>1 走bcd联合索引 using index(覆盖索引) 因为联合索引叶子节点中包含b字段
select b from t, 从左往右扫描bcd索引叶子节点 using index(覆盖索引) 因为联合索引叶子节点中包含b字段 而且bcd联合索引数据量小，一页可以存储更多的数据，所以查询效率比从 左往右扫描主键索引叶子节点 高
select * from t, 全表扫描

select * from t order by b,c,d   走bcd联合索引 叶子节点已经按照bcd排好序了，但需要回表
                                 全表扫描，额外排序（内存，速度很快） 不需要回表 （更好）

select b from t order by b,c,d   走bcd联合索引 叶子节点已经按照bcd排好序了，节点有b字段 不用回表（更好）
                                 全表扫描，额外排序（内存） 不需要回表

mysql中类型转换
字符转数字 非数字字段统一转换成0 数字字符转换成对应的数字
select 'a'=0
select '123'=123

聚簇索引和非聚簇索引
innodb  主键是聚簇索引，其他的辅助索引都是非聚簇索引
MyISAM  主键索引和辅助索引都是非聚簇索引、
区别：从增删改查角度看  查一次查两次  删改更新索引